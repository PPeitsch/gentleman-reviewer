#!/usr/bin/env bash

# ============================================================================
# Gentleman Guardian Angel - Provider-agnostic code review using AI
# ============================================================================
# A standalone CLI tool that validates staged files against your project's
# coding standards using any AI provider (Claude, Gemini, Codex, Ollama, etc.)
# ============================================================================

set -e

VERSION="2.9.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"

# Source library functions
# shellcheck source=lib/providers.sh
source "$LIB_DIR/providers.sh"
# shellcheck source=lib/cache.sh
source "$LIB_DIR/cache.sh"
# shellcheck source=lib/pr_mode.sh
source "$LIB_DIR/pr_mode.sh"

# ============================================================================
# Signal Handling - Graceful cleanup on interruption
# ============================================================================
# This ensures we exit cleanly without leaving git index in a bad state
# when user presses Ctrl+C or the process is terminated

cleanup() {
  local exit_code=$?
  # Stop spinner if running
  stop_spinner
  # Reset terminal colors in case we were in the middle of output
  echo -e "\033[0m" 2>/dev/null || true
  exit $exit_code
}

# Trap common signals for graceful cleanup
trap cleanup EXIT
trap 'exit 130' INT   # Ctrl+C - exit with 128+2
trap 'exit 143' TERM  # kill - exit with 128+15

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Spinner state
SPINNER_PID=""

# ============================================================================
# Spinner Functions
# ============================================================================

start_spinner() {
  local message="${1:-Processing...}"

  # Only show spinner if stderr is a terminal (use stderr so $() doesn't capture it)
  if [[ ! -t 2 ]]; then
    return
  fi

  # Spinner characters (braille pattern)
  local spinner_chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
  # Capture colors for subshell (variables don't inherit to background process)
  local cyan=$'\033[0;36m'
  local nc=$'\033[0m'

  (
    local i=0
    local len=${#spinner_chars}
    while true; do
      local char="${spinner_chars:$i:1}"
      printf "\r%s%s%s %s" "$cyan" "$char" "$nc" "$message" >&2
      i=$(( (i + 1) % len ))
      sleep 0.1
    done
  ) &

  SPINNER_PID=$!
  # Ensure spinner is killed if script exits
  disown "$SPINNER_PID" 2>/dev/null || true
}

stop_spinner() {
  # Only if spinner was started
  if [[ -z "$SPINNER_PID" ]]; then
    return
  fi

  # Kill spinner process
  if kill -0 "$SPINNER_PID" 2>/dev/null; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
  fi

  SPINNER_PID=""

  # Clear spinner line (only if stderr is terminal)
  if [[ -t 2 ]]; then
    printf "\r\033[K" >&2
  fi
}

# ============================================================================
# Output Formatting
# ============================================================================

format_review_output() {
  local result="$1"

  # If stdout is not a terminal, output plain text without formatting
  if [[ ! -t 1 ]]; then
    echo "$result"
    return
  fi

  # Print separator before output
  echo -e "${CYAN}─────────${NC} ${BOLD}Review Result${NC} ${CYAN}─────────${NC}"
  echo ""

  # Process each line and apply formatting
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Colorize STATUS: PASSED (handle markdown bold syntax too)
    if [[ "$line" =~ ^\*?\*?STATUS:[[:space:]]*PASSED\*?\*?$ ]] || [[ "$line" =~ ^STATUS:[[:space:]]*PASSED ]]; then
      echo -e "${GREEN}${BOLD}${line}${NC}"
    # Colorize STATUS: FAILED (handle markdown bold syntax too)
    elif [[ "$line" =~ ^\*?\*?STATUS:[[:space:]]*FAILED\*?\*?$ ]] || [[ "$line" =~ ^STATUS:[[:space:]]*FAILED ]]; then
      echo -e "${RED}${BOLD}${line}${NC}"
    # Colorize numbered findings (#N file:line - ...)
    elif [[ "$line" =~ ^#([0-9]+)[[:space:]]([^[:space:]]+)(.*) ]]; then
      local num="${BASH_REMATCH[1]}"
      local file="${BASH_REMATCH[2]}"
      local rest="${BASH_REMATCH[3]}"
      echo -e "${YELLOW}#${num}${NC} ${CYAN}${file}${NC}${rest}"
    else
      echo "$line"
    fi
  done <<< "$result"

  echo ""
  echo -e "${CYAN}──────────────────────────────────${NC}"
}

# ============================================================================
# GGA Ignore Functions
# ============================================================================

DEFAULT_GGA_IGNORE_FILE=".gga-ignore"

# Load entries from .gga-ignore file
# Returns one entry per line in format: file:line  # reason
load_gga_ignore() {
  local ignore_file="${1:-$DEFAULT_GGA_IGNORE_FILE}"

  if [[ ! -f "$ignore_file" ]]; then
    return
  fi

  # Read file, skip comments and blank lines
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip empty lines and comment-only lines
    line=$(echo "$line" | sed 's/^[[:space:]]*//')
    if [[ -z "$line" || "$line" == \#* ]]; then
      continue
    fi
    echo "$line"
  done < "$ignore_file"
}

# Check if a file:line is in the ignore list
# Returns 0 if ignored, 1 if not
is_finding_ignored() {
  local file_line="$1"
  local ignore_entries="$2"

  if [[ -z "$ignore_entries" ]]; then
    return 1
  fi

  while IFS= read -r entry; do
    # Extract file:line from entry (before the # comment)
    local entry_file_line
    entry_file_line=$(echo "$entry" | sed 's/[[:space:]]*#.*$//' | sed 's/[[:space:]]*$//')
    if [[ "$entry_file_line" == "$file_line" ]]; then
      return 0
    fi
  done <<< "$ignore_entries"

  return 1
}

# Parse findings from AI output
# Extracts lines matching: #N file:line - rule - description
# Outputs: N|file:line|full_line (pipe-separated)
parse_findings() {
  local ai_output="$1"

  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^#([0-9]+)[[:space:]]([^[:space:]]+)(.*) ]]; then
      local num="${BASH_REMATCH[1]}"
      local file_ref="${BASH_REMATCH[2]}"
      echo "${num}|${file_ref}|${line}"
    fi
  done <<< "$ai_output"
}

# Add an entry to .gga-ignore
add_to_gga_ignore() {
  local file_line="$1"
  local reason="$2"
  local ignore_file="${3:-$DEFAULT_GGA_IGNORE_FILE}"

  # Create file with header if it doesn't exist
  if [[ ! -f "$ignore_file" ]]; then
    echo "# .gga-ignore - Dismissed review findings" > "$ignore_file"
    echo "# Format: file:line  # reason" >> "$ignore_file"
    echo "" >> "$ignore_file"
  fi

  echo "${file_line}  # ${reason}" >> "$ignore_file"
}

# Interactive dismiss flow after a FAILED review
# Returns the number of remaining (non-dismissed) findings
prompt_dismiss_findings() {
  local ai_output="$1"

  # Parse findings from the AI output
  local findings
  findings=$(parse_findings "$ai_output")

  if [[ -z "$findings" ]]; then
    # No parseable findings, can't dismiss
    return 1
  fi

  # Build array of finding numbers for validation
  local valid_numbers=""
  while IFS='|' read -r num file_ref full_line; do
    if [[ -n "$num" ]]; then
      valid_numbers="${valid_numbers} ${num}"
    fi
  done <<< "$findings"

  echo ""
  # Read from /dev/tty for git hook compatibility
  # Print prompt to /dev/tty explicitly (read -p doesn't work well with stdin redirection)
  local dismiss_input
  printf "Dismiss findings? (#s comma-separated, Enter to skip): " > /dev/tty
  read -r dismiss_input < /dev/tty 2>/dev/null || return 1
  echo ""

  if [[ -z "$dismiss_input" ]]; then
    # User pressed Enter without input — skip dismissal
    return 1
  fi

  # Parse comma-separated numbers
  IFS=',' read -ra dismiss_numbers <<< "$dismiss_input"

  local dismissed_count=0
  for raw_num in "${dismiss_numbers[@]}"; do
    # Clean: strip whitespace and leading #
    local num
    num=$(echo "$raw_num" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/^#//')

    if [[ -z "$num" ]]; then
      continue
    fi

    # Validate number is in the findings
    if ! echo "$valid_numbers" | grep -qw "$num"; then
      log_warning "Finding #${num} not found, skipping"
      continue
    fi

    # Find the file:line for this number
    local file_ref=""
    while IFS='|' read -r fnum fref fline; do
      if [[ "$fnum" == "$num" ]]; then
        file_ref="$fref"
        break
      fi
    done <<< "$findings"

    if [[ -z "$file_ref" ]]; then
      continue
    fi

    # Prompt for reason
    local reason
    printf "Reason for #${num}: " > /dev/tty
    read -r reason < /dev/tty 2>/dev/null || reason="dismissed"

    if [[ -z "$reason" ]]; then
      reason="dismissed"
    fi

    # Add to .gga-ignore
    add_to_gga_ignore "$file_ref" "$reason"
    log_success "Added to .gga-ignore: ${file_ref}"
    echo ""
    dismissed_count=$((dismissed_count + 1))
  done

  if [[ $dismissed_count -eq 0 ]]; then
    return 1
  fi

  # Count total and remaining findings
  local total_findings=0
  while IFS='|' read -r num file_ref full_line; do
    [[ -n "$num" ]] && total_findings=$((total_findings + 1))
  done <<< "$findings"

  local remaining=$((total_findings - dismissed_count))

  echo ""
  if [[ $remaining -eq 0 ]]; then
    echo -e "${GREEN}All findings dismissed.${NC}"
    return 0
  else
    # Show remaining findings
    echo -e "${BOLD}Remaining findings:${NC}"
    while IFS='|' read -r fnum fref fline; do
      if [[ -n "$fnum" ]]; then
        # Check if this finding was NOT dismissed
        local was_dismissed=false
        for raw_num in "${dismiss_numbers[@]}"; do
          local dnum
          dnum=$(echo "$raw_num" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/^#//')
          if [[ "$dnum" == "$fnum" ]]; then
            was_dismissed=true
            break
          fi
        done
        if [[ "$was_dismissed" == false ]]; then
          echo "$fline"
        fi
      fi
    done <<< "$findings"
    return $remaining
  fi
}

# Handle gga ignore subcommands
cmd_ignore() {
  local subcommand="${1:-list}"

  case "$subcommand" in
    list)
      print_banner
      local entries
      entries=$(load_gga_ignore)

      if [[ -z "$entries" ]]; then
        log_info "No entries in .gga-ignore"
        if [[ ! -f "$DEFAULT_GGA_IGNORE_FILE" ]]; then
          echo "  File does not exist yet."
        else
          echo "  File exists but has no active entries."
        fi
      else
        echo -e "${BOLD}Ignored findings:${NC}"
        echo ""
        while IFS= read -r entry; do
          echo "  $entry"
        done <<< "$entries"
      fi
      echo ""
      ;;
    clear)
      print_banner
      if [[ -f "$DEFAULT_GGA_IGNORE_FILE" ]]; then
        rm "$DEFAULT_GGA_IGNORE_FILE"
        log_success "Removed .gga-ignore"
      else
        log_info "No .gga-ignore file to remove"
      fi
      echo ""
      ;;
    *)
      log_error "Unknown ignore command: $subcommand"
      echo ""
      echo "Available commands:"
      echo "  gga ignore list   - Show ignored findings"
      echo "  gga ignore clear  - Remove .gga-ignore file"
      echo ""
      exit 1
      ;;
  esac
}

# Defaults
DEFAULT_FILE_PATTERNS="*"
DEFAULT_RULES_FILE="REVIEW_RULES.md"
DEFAULT_LEGACY_RULES_FILE="AGENTS.md"
DEFAULT_STRICT_MODE="true"
DEFAULT_MAX_FILE_SIZE="100000"  # 100KB in bytes, 0 = no limit
DEFAULT_RETRY_COUNT="3"         # Number of retry attempts
DEFAULT_RETRY_DELAY="2"         # Initial delay in seconds (doubles each retry)
DEFAULT_FALLBACK_PROVIDER=""    # Fallback provider if primary fails (empty = no fallback)
DEFAULT_MAX_PROMPT_SIZE="50000" # Max prompt size in characters (0 = no limit, triggers batching)
DEFAULT_TIMEOUT="300"           # 5 minutes - generous default for large reviews

# ============================================================================
# Helper Functions
# ============================================================================

print_banner() {
  echo ""
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${CYAN}${BOLD}  Gentleman Guardian Angel v${VERSION}${NC}"
  echo -e "${CYAN}  Provider-agnostic code review using AI${NC}"
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
}

print_help() {
  print_banner
  echo -e "${BOLD}USAGE:${NC}"
  echo "  gga <command> [options]"
  echo ""
  echo -e "${BOLD}COMMANDS:${NC}"
  echo "  run [--no-cache]  Run code review on staged files"
  echo "  install           Install git pre-commit hook (default)"
  echo "  install --commit-msg"
  echo "                    Install git commit-msg hook (for commit message validation)"
  echo "  uninstall         Remove git hooks from current repo"
  echo "  config            Show current configuration"
  echo "  init              Create a sample .gga config file"
  echo "  cache clear       Clear cache for current project"
  echo "  cache clear-all   Clear all cached data"
  echo "  cache status      Show cache status"
  echo "  ignore list       Show dismissed findings (.gga-ignore)"
  echo "  ignore clear      Remove .gga-ignore file"
  echo "  help              Show this help message"
  echo "  version           Show version"
  echo ""
  echo -e "${BOLD}RUN OPTIONS:${NC}"
  echo "  --no-cache        Force review all files, ignoring cache"
  echo "  --ci              CI mode: review files changed in last commit (HEAD~1..HEAD)"
  echo "                    Use this in GitLab CI, GitHub Actions, etc."
  echo "  --force           Ignore MAX_FILE_SIZE limit (may fail due to context limits)"
  echo "  --pr-mode         PR mode: review all files changed in the full PR"
  echo "                    Auto-detects base branch (main/master/develop)"
  echo "  --diff-only       With --pr-mode: send only diffs (faster, cheaper)"
  echo ""
  echo -e "${BOLD}CONFIGURATION:${NC}"
  echo "  Create a ${CYAN}.gga${NC} file in your project root or"
  echo "  ${CYAN}~/.config/gga/config${NC} for global settings."
  echo ""
  echo -e "${BOLD}CONFIG OPTIONS:${NC}"
  echo "  PROVIDER           AI provider to use (required)"
  echo "                     Values: claude, gemini, codex, opencode, ollama:<model>, lmstudio[:model], github:<model>"
  echo "  FILE_PATTERNS      File patterns to review (default: *)"
  echo "                     Example: *.ts,*.tsx,*.js,*.jsx"
  echo "  EXCLUDE_PATTERNS   Patterns to exclude from review"
  echo "                     Example: *.test.ts,*.spec.ts,*.d.ts"
  echo "  RULES_FILE         File containing review rules (default: REVIEW_RULES.md)"
  echo "  STRICT_MODE        Fail on ambiguous AI response (default: true)"
  echo "  MAX_FILE_SIZE      Max file size in bytes, 0=no limit (default: 100000)"
  echo "  RETRY_COUNT        Number of retry attempts on failure (default: 3)"
  echo "  RETRY_DELAY        Initial retry delay in seconds (default: 2)"
  echo "  FALLBACK_PROVIDER  Fallback provider if primary fails (default: none)"
  echo "  MAX_PROMPT_SIZE    Max prompt size in chars, 0=no limit (default: 50000)"
  echo "                     Splits into batches when exceeded"
  echo "  TIMEOUT            Max seconds to wait for AI response (default: 300)"
  echo "  PR_BASE_BRANCH     Base branch for --pr-mode (default: auto-detect)"
  echo ""
  echo -e "${BOLD}EXAMPLES:${NC}"
  echo "  gga init               # Create sample config"
  echo "  gga install            # Install pre-commit hook (default)"
  echo "  gga install --commit-msg  # Install commit-msg hook"
  echo "  gga run                # Run review (with cache)"
  echo "  gga run --no-cache     # Run review (ignore cache)"
  echo "  gga run --ci           # Run review in CI (last commit)"
  echo "  gga run --pr-mode      # Review full PR changes"
  echo "  gga run --pr-mode --diff-only  # Review PR diffs only"
  echo "  gga cache status       # Show cache info"
  echo ""
  echo -e "${BOLD}ENVIRONMENT VARIABLES:${NC}"
  echo "  GGA_PROVIDER      Override provider from config"
  echo "  GGA_TIMEOUT       Override timeout from config (seconds)"
  echo ""
}

print_version() {
  echo "gga v${VERSION}"
}

log_info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
  echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
  echo -e "${RED}❌ $1${NC}"
}

# ============================================================================
# Configuration Loading
# ============================================================================

load_config() {
  # Reset to defaults
  PROVIDER=""
  FILE_PATTERNS="$DEFAULT_FILE_PATTERNS"
  EXCLUDE_PATTERNS=""
  RULES_FILE="$DEFAULT_RULES_FILE"
  STRICT_MODE="$DEFAULT_STRICT_MODE"
  MAX_FILE_SIZE="$DEFAULT_MAX_FILE_SIZE"
  RETRY_COUNT="$DEFAULT_RETRY_COUNT"
  RETRY_DELAY="$DEFAULT_RETRY_DELAY"
  FALLBACK_PROVIDER="$DEFAULT_FALLBACK_PROVIDER"
  MAX_PROMPT_SIZE="$DEFAULT_MAX_PROMPT_SIZE"
  TIMEOUT="$DEFAULT_TIMEOUT"
  PR_BASE_BRANCH=""

  # Load global config first
  GLOBAL_CONFIG="$HOME/.config/gga/config"
  if [[ -f "$GLOBAL_CONFIG" ]]; then
    # shellcheck source=/dev/null
    source "$GLOBAL_CONFIG"
  fi

  # Load project config (overrides global)
  PROJECT_CONFIG=".gga"
  if [[ -f "$PROJECT_CONFIG" ]]; then
    # shellcheck source=/dev/null
    source "$PROJECT_CONFIG"
  fi

  # Environment variable overrides everything
  if [[ -n "$GGA_PROVIDER" ]]; then
    PROVIDER="$GGA_PROVIDER"
  fi
  if [[ -n "${GGA_TIMEOUT:-}" ]]; then
    TIMEOUT="$GGA_TIMEOUT"
  fi
}

# ============================================================================
# Commands
# ============================================================================

cmd_config() {
  print_banner
  load_config

  echo -e "${BOLD}Current Configuration:${NC}"
  echo ""
  
  # Check config sources
  GLOBAL_CONFIG="$HOME/.config/gga/config"
  PROJECT_CONFIG=".gga"
  
  echo -e "${BOLD}Config Files:${NC}"
  if [[ -f "$GLOBAL_CONFIG" ]]; then
    echo -e "  Global:  ${GREEN}$GLOBAL_CONFIG${NC}"
  else
    echo -e "  Global:  ${YELLOW}Not found${NC}"
  fi
  
  if [[ -f "$PROJECT_CONFIG" ]]; then
    echo -e "  Project: ${GREEN}$PROJECT_CONFIG${NC}"
  else
    echo -e "  Project: ${YELLOW}Not found${NC}"
  fi
  echo ""

  echo -e "${BOLD}Values:${NC}"
  if [[ -n "$PROVIDER" ]]; then
    echo -e "  PROVIDER:          ${GREEN}$PROVIDER${NC}"
  else
    echo -e "  PROVIDER:          ${RED}Not configured${NC}"
  fi
  echo -e "  FILE_PATTERNS:     ${CYAN}$FILE_PATTERNS${NC}"
  if [[ -n "$EXCLUDE_PATTERNS" ]]; then
    echo -e "  EXCLUDE_PATTERNS:  ${CYAN}$EXCLUDE_PATTERNS${NC}"
  else
    echo -e "  EXCLUDE_PATTERNS:  ${YELLOW}None${NC}"
  fi
  echo -e "  RULES_FILE:        ${CYAN}$RULES_FILE${NC}"
  echo -e "  STRICT_MODE:       ${CYAN}$STRICT_MODE${NC}"
  echo -e "  MAX_FILE_SIZE:     ${CYAN}$MAX_FILE_SIZE${NC}"
  echo -e "  RETRY_COUNT:       ${CYAN}$RETRY_COUNT${NC}"
  echo -e "  RETRY_DELAY:       ${CYAN}${RETRY_DELAY}s${NC}"
  if [[ -n "$FALLBACK_PROVIDER" ]]; then
    echo -e "  FALLBACK_PROVIDER: ${CYAN}$FALLBACK_PROVIDER${NC}"
  else
    echo -e "  FALLBACK_PROVIDER: ${YELLOW}None${NC}"
  fi
  if [[ -n "$MAX_PROMPT_SIZE" && "$MAX_PROMPT_SIZE" != "0" ]]; then
    echo -e "  MAX_PROMPT_SIZE:   ${CYAN}$MAX_PROMPT_SIZE${NC} (chars)"
  else
    echo -e "  MAX_PROMPT_SIZE:   ${YELLOW}No limit${NC}"
  fi
  echo -e "  TIMEOUT:           ${CYAN}${TIMEOUT}s${NC}"
  if [[ -n "${PR_BASE_BRANCH:-}" ]]; then
    echo -e "  PR_BASE_BRANCH:    ${CYAN}$PR_BASE_BRANCH${NC}"
  else
    echo -e "  PR_BASE_BRANCH:    ${YELLOW}auto-detect${NC}"
  fi
  echo ""

  # Check if rules file exists
  if [[ -f "$RULES_FILE" ]]; then
    echo -e "${BOLD}Rules File:${NC} ${GREEN}Found${NC}"
  else
    echo -e "${BOLD}Rules File:${NC} ${RED}Not found ($RULES_FILE)${NC}"
  fi
  echo ""
}

cmd_init() {
  print_banner
  
  PROJECT_CONFIG=".gga"
  
  if [[ -f "$PROJECT_CONFIG" ]]; then
    log_warning "Config file already exists: $PROJECT_CONFIG"
    read -rp "Overwrite? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo "Aborted."
      exit 0
    fi
  fi

  cat > "$PROJECT_CONFIG" << 'EOF'
# Gentleman Guardian Angel Configuration
# https://github.com/your-org/gga

# AI Provider (required)
# Options: claude, gemini, codex, opencode, ollama:<model>, lmstudio[:model], github:<model>
# Examples:
#   PROVIDER="claude"
#   PROVIDER="gemini"
#   PROVIDER="codex"
#   PROVIDER="opencode"
#   PROVIDER="opencode:anthropic/claude-opus-4-5"
#   PROVIDER="ollama:llama3.2"
#   PROVIDER="ollama:codellama"
#   PROVIDER="lmstudio"
#   PROVIDER="lmstudio:qwen2.5-coder-7b-instruct"
#   PROVIDER="github:gpt-4o"
#   PROVIDER="github:deepseek-r1"
PROVIDER="claude"

# File patterns to include in review (comma-separated)
# Default: * (all files)
# Examples:
#   FILE_PATTERNS="*.ts,*.tsx"
#   FILE_PATTERNS="*.py"
#   FILE_PATTERNS="*.go,*.mod"
FILE_PATTERNS="*.ts,*.tsx,*.js,*.jsx"

# File patterns to exclude from review (comma-separated)
# Default: none
# Examples:
#   EXCLUDE_PATTERNS="*.test.ts,*.spec.ts"
#   EXCLUDE_PATTERNS="*_test.go,*.mock.ts"
EXCLUDE_PATTERNS="*.test.ts,*.spec.ts,*.test.tsx,*.spec.tsx,*.d.ts"

# File containing code review rules
# Default: REVIEW_RULES.md (AGENTS.md is supported for backwards compatibility)
RULES_FILE="REVIEW_RULES.md"

# Strict mode: fail if AI response is ambiguous
# Default: true
STRICT_MODE="true"

# Maximum file size in bytes (0 = no limit)
# Files exceeding this limit will block the review
# Use --force to override
# Default: 100000 (100KB)
MAX_FILE_SIZE="100000"

# Retry settings for provider failures
# RETRY_COUNT: Number of retry attempts (default: 3)
# RETRY_DELAY: Initial delay in seconds, doubles each retry (default: 2)
RETRY_COUNT="3"
RETRY_DELAY="2"

# Fallback provider if primary provider fails after all retries
# Leave empty to disable fallback
# Example: FALLBACK_PROVIDER="gemini"
FALLBACK_PROVIDER=""

# Maximum prompt size in characters (0 = no limit)
# When exceeded, files are split into batches and reviewed separately
# Default: 50000
MAX_PROMPT_SIZE="50000"

# Timeout in seconds for AI provider response
# Default: 300 (5 minutes)
# Increase for large changesets or slow connections
TIMEOUT="300"

# Base branch for --pr-mode (auto-detects main/master/develop if empty)
# Default: auto-detect
# PR_BASE_BRANCH="main"
EOF

  log_success "Created config file: $PROJECT_CONFIG"
  echo ""
  log_info "Next steps:"
  echo "  1. Edit $PROJECT_CONFIG to set your preferred provider"
  echo "  2. Create $DEFAULT_RULES_FILE with your coding standards"
  echo "  3. Run: gga install"
  echo ""
}

# Markers for GGA hook section (used for clean install/uninstall)
GGA_MARKER_START="# ======== GGA START ========"
GGA_MARKER_END="# ======== GGA END ========"

cmd_install() {
  print_banner

  # Check if we're in a git repo
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not a git repository"
    exit 1
  fi

  # Parse arguments to determine hook type
  local hook_type="pre-commit"  # default
  
  for arg in "$@"; do
    case "$arg" in
      --commit-msg)
        hook_type="commit-msg"
        ;;
    esac
  done

  # Use --git-path hooks to get the correct hooks directory
  # This works correctly for both regular repos and worktrees:
  # - Regular repo: returns .git/hooks
  # - Worktree: returns the main repo's .git/hooks (where git actually looks)
  HOOKS_DIR=$(git rev-parse --git-path hooks)
  HOOK_PATH="$HOOKS_DIR/$hook_type"
  
  # Ensure hooks directory exists (may not exist in fresh repos)
  mkdir -p "$HOOKS_DIR"

  # Determine the gga run command based on hook type
  # commit-msg hook receives the commit message file as $1, which GGA uses automatically
  local gga_run_cmd
  if [[ "$hook_type" == "commit-msg" ]]; then
    # shellcheck disable=SC2016 # We intentionally use single quotes - $1 expands when hook runs, not now
    gga_run_cmd='gga run "$1" || exit 1'
  else
    gga_run_cmd='gga run || exit 1'
  fi

  # Check if hook already exists
  if [[ -f "$HOOK_PATH" ]]; then
    # Check for legacy ai-code-review and migrate
    if grep -q "ai-code-review" "$HOOK_PATH"; then
      log_warning "Found legacy 'ai-code-review' in hook, migrating to 'gga'..."
      if [[ "$(uname)" == "Darwin" ]]; then
        sed -i '' 's/ai-code-review/gga/g' "$HOOK_PATH"
        sed -i '' 's/AI Code Review/Gentleman Guardian Angel/g' "$HOOK_PATH"
      else
        sed -i 's/ai-code-review/gga/g' "$HOOK_PATH"
        sed -i 's/AI Code Review/Gentleman Guardian Angel/g' "$HOOK_PATH"
      fi
      log_success "Migrated hook to use 'gga'"
      exit 0
    fi

    # Check if GGA is already installed (using markers)
    if grep -q "$GGA_MARKER_START" "$HOOK_PATH"; then
      log_warning "Gentleman Guardian Angel hook already installed in $hook_type"
      exit 0
    fi
    
    # Existing hook without GGA - insert with markers
    log_info "Existing $hook_type hook found, adding GGA..."
    
    # Build the GGA block
    local gga_block
    gga_block=$(printf '\n%s\n%s\n%s\n%s' \
      "$GGA_MARKER_START" \
      "# Gentleman Guardian Angel - Code Review" \
      "$gga_run_cmd" \
      "$GGA_MARKER_END")
    
    # Check if hook ends with 'exit 0' or 'exit' (with optional whitespace)
    # If so, insert GGA block before the final exit to ensure it runs
    if grep -Eq '^[[:space:]]*exit[[:space:]]*[0-9]*[[:space:]]*$' "$HOOK_PATH"; then
      # Find the last exit line and insert before it
      local last_exit_line
      last_exit_line=$(grep -n '^[[:space:]]*exit[[:space:]]*[0-9]*[[:space:]]*$' "$HOOK_PATH" | tail -1 | cut -d: -f1)
      
      if [[ -n "$last_exit_line" ]]; then
        # Insert GGA block before the last exit line
        local temp_file
        temp_file=$(mktemp)
        {
          head -n $((last_exit_line - 1)) "$HOOK_PATH"
          echo "$gga_block"
          echo ""
          tail -n +"$last_exit_line" "$HOOK_PATH"
        } > "$temp_file"
        mv "$temp_file" "$HOOK_PATH"
        chmod +x "$HOOK_PATH"
        log_success "Inserted Gentleman Guardian Angel before exit in $hook_type hook: $HOOK_PATH"
        echo ""
        exit 0
      fi
    fi
    
    # No exit statement found, append to end
    echo "$gga_block" >> "$HOOK_PATH"
    log_success "Appended Gentleman Guardian Angel to existing $hook_type hook: $HOOK_PATH"
    echo ""
    exit 0
  fi

  # Create new hook with markers
  cat > "$HOOK_PATH" << EOF
#!/usr/bin/env bash

$GGA_MARKER_START
# Gentleman Guardian Angel - Code Review
$gga_run_cmd
$GGA_MARKER_END
EOF

  chmod +x "$HOOK_PATH"
  log_success "Installed $hook_type hook: $HOOK_PATH"
  echo ""
}

cmd_uninstall() {
  print_banner

  # Check if we're in a git repo
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not a git repository"
    exit 1
  fi

  # Use --git-path hooks to get the correct hooks directory
  # This works correctly for both regular repos and worktrees
  HOOKS_DIR=$(git rev-parse --git-path hooks)
  
  local found_any=false

  # Check both hook types
  for hook_type in "pre-commit" "commit-msg"; do
    local hook_path="$HOOKS_DIR/$hook_type"
    
    if [[ -f "$hook_path" ]] && grep -q "gga" "$hook_path"; then
      found_any=true
      uninstall_from_hook "$hook_path" "$hook_type"
    fi
  done

  if [[ "$found_any" == false ]]; then
    log_warning "Gentleman Guardian Angel hook not found"
  fi
  
  echo ""
}

# Helper function to uninstall GGA from a specific hook file
uninstall_from_hook() {
  local hook_path="$1"
  local hook_name="$2"

  # Check for GGA using markers first (new format)
  if grep -q "$GGA_MARKER_START" "$hook_path"; then
    # Remove content between markers (inclusive)
    if [[ "$(uname)" == "Darwin" ]]; then
      sed -i '' "/$GGA_MARKER_START/,/$GGA_MARKER_END/d" "$hook_path"
    else
      sed -i "/$GGA_MARKER_START/,/$GGA_MARKER_END/d" "$hook_path"
    fi
    
    # Check if file is now empty or only has shebang/whitespace
    local remaining_content
    remaining_content=$(grep -Ecv '^#!|^[[:space:]]*$' "$hook_path" || true)
    if [[ "$remaining_content" -eq 0 ]]; then
      rm "$hook_path"
      log_success "Removed $hook_name hook (was GGA-only)"
    else
      log_success "Removed Gentleman Guardian Angel from $hook_name hook"
    fi
    return
  fi

  # Legacy format: check if it's our hook only or mixed
  if grep -q "^gga run" "$hook_path" && [[ $(wc -l < "$hook_path") -le 6 ]]; then
    # It's only our hook, remove the file
    rm "$hook_path"
    log_success "Removed $hook_name hook"
  else
    # Mixed hook, just remove our lines (legacy format)
    if [[ "$(uname)" == "Darwin" ]]; then
      sed -i '' '/# Gentleman Guardian Angel/d' "$hook_path"
      sed -i '' '/gga run/d' "$hook_path"
    else
      sed -i '/# Gentleman Guardian Angel/d' "$hook_path"
      sed -i '/gga run/d' "$hook_path"
    fi
    log_success "Removed Gentleman Guardian Angel from $hook_name hook"
  fi
}

cmd_cache() {
  local subcommand="${1:-status}"
  
  print_banner
  
  case "$subcommand" in
    clear)
      clear_project_cache
      log_success "Cleared cache for current project"
      echo ""
      ;;
    clear-all)
      clear_all_cache
      log_success "Cleared all cache data"
      echo ""
      ;;
    status)
      load_config
      
      local cache_dir
      cache_dir=$(get_project_cache_dir)
      
      echo -e "${BOLD}Cache Status:${NC}"
      echo ""
      
      if [[ -z "$cache_dir" ]]; then
        echo -e "  Project cache: ${YELLOW}Not initialized (not in a git repo?)${NC}"
      elif [[ ! -d "$cache_dir" ]]; then
        echo -e "  Project cache: ${YELLOW}Not initialized${NC}"
      else
        echo -e "  Cache directory: ${CYAN}$cache_dir${NC}"
        
        # Check if cache is valid
        if is_cache_valid "$RULES_FILE" ".gga"; then
          echo -e "  Cache validity: ${GREEN}Valid${NC}"
        else
          echo -e "  Cache validity: ${YELLOW}Invalid (rules or config changed)${NC}"
        fi
        
        # Count cached files
        local cached_count=0
        if [[ -d "$cache_dir/files" ]]; then
          cached_count=$(find "$cache_dir/files" -type f 2>/dev/null | wc -l | xargs)
        fi
        echo -e "  Cached files: ${CYAN}$cached_count${NC}"
        
        # Show cache size
        if command -v du &> /dev/null; then
          local cache_size
          cache_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)
          echo -e "  Cache size: ${CYAN}$cache_size${NC}"
        fi
      fi
      echo ""
      ;;
    *)
      log_error "Unknown cache command: $subcommand"
      echo ""
      echo "Available commands:"
      echo "  gga cache status     - Show cache status"
      echo "  gga cache clear      - Clear project cache"
      echo "  gga cache clear-all  - Clear all cache"
      echo ""
      exit 1
      ;;
  esac
}

cmd_run() {
  local use_cache=true
  local ci_mode=false
  local force_mode=false
  local pr_mode=false
  local diff_only=false
  local commit_msg_file=""

  # Parse arguments
  for arg in "$@"; do
    case "$arg" in
      --no-cache)
        use_cache=false
        ;;
      --ci)
        ci_mode=true
        use_cache=false  # Cache doesn't make sense in CI
        ;;
      --force)
        force_mode=true
        ;;
      --pr-mode)
        pr_mode=true
        use_cache=false  # Cache doesn't make sense in PR mode
        ;;
      --diff-only)
        diff_only=true
        ;;
      *)
        # Non-flag argument is the commit message file (from commit-msg hook)
        if [[ -f "$arg" ]]; then
          commit_msg_file="$arg"
        fi
        ;;
    esac
  done

  # Determine if we should read from staging area
  # In CI mode or PR mode, files are already committed so we read from filesystem
  local use_staged="true"
  if [[ "$ci_mode" == "true" || "$pr_mode" == "true" ]]; then
    use_staged="false"
  fi

  # Validate flag combinations
  if ! validate_pr_mode_flags "$pr_mode" "$diff_only"; then
    exit 1
  fi

  print_banner
  load_config

  # Fallback: if REVIEW_RULES.md doesn't exist but AGENTS.md does, use AGENTS.md
  # This provides backwards compatibility during the transition
  if [[ "$RULES_FILE" == "$DEFAULT_RULES_FILE" && ! -f "$RULES_FILE" && -f "$DEFAULT_LEGACY_RULES_FILE" ]]; then
    RULES_FILE="$DEFAULT_LEGACY_RULES_FILE"
    log_warning "Using deprecated $DEFAULT_LEGACY_RULES_FILE (rename to $DEFAULT_RULES_FILE)"
  fi

  # Validate provider is configured
  if [[ -z "$PROVIDER" ]]; then
    log_error "No provider configured"
    echo ""
    echo "Configure a provider in .gga or set GGA_PROVIDER"
    echo "Run 'gga init' to create a config file"
    echo ""
    exit 1
  fi

  # Validate provider is available
  if ! validate_provider "$PROVIDER"; then
    exit 1
  fi

  # Check rules file exists
  if [[ ! -f "$RULES_FILE" ]]; then
    log_error "Rules file not found: $RULES_FILE"
    echo ""
    echo "Please create a ${BOLD}$RULES_FILE${NC} file with your coding standards."
    echo ""
    echo "Example content:"
    echo "  # Code Review Rules"
    echo "  "
    echo "  ## TypeScript"
    echo "  - Use const/let, never var"
    echo "  - Prefer interfaces over types"
    echo "  - No any types"
    echo "  "
    echo "  ## React"
    echo "  - Use functional components"
    echo "  - Prefer named exports"
    echo ""
    exit 1
  fi

  log_info "Provider: $PROVIDER"
  log_info "Rules file: $RULES_FILE"
  log_info "File patterns: $FILE_PATTERNS"
  if [[ -n "$EXCLUDE_PATTERNS" ]]; then
    log_info "Exclude patterns: $EXCLUDE_PATTERNS"
  fi
  
  # Mode status
  if [[ "$pr_mode" == true ]]; then
    if [[ "$diff_only" == true ]]; then
      log_info "Mode: ${CYAN}PR (diff-only review)${NC}"
    else
      log_info "Mode: ${CYAN}PR (full file review)${NC}"
    fi
  elif [[ "$ci_mode" == true ]]; then
    log_info "Mode: ${CYAN}CI (reviewing last commit)${NC}"
  fi
  
  # Cache status
  if [[ "$use_cache" == true ]]; then
    log_info "Cache: ${GREEN}enabled${NC}"
  elif [[ "$pr_mode" == true ]]; then
    log_info "Cache: ${YELLOW}disabled (PR mode)${NC}"
  elif [[ "$ci_mode" == true ]]; then
    log_info "Cache: ${YELLOW}disabled (CI mode)${NC}"
  else
    log_info "Cache: ${YELLOW}disabled (--no-cache)${NC}"
  fi
  echo ""

  # Get files to review based on mode
  local FILES_TO_CHECK
  local pr_range=""
  local pr_base=""
  if [[ "$pr_mode" == true ]]; then
    # PR mode: get files changed in the full PR range
    if ! pr_range=$(get_pr_range "${PR_BASE_BRANCH:-}"); then
      log_error "Could not determine PR range"
      echo ""
      echo "Set PR_BASE_BRANCH in your .gga config to specify the base branch."
      echo "  Example: PR_BASE_BRANCH=\"main\""
      echo ""
      exit 1
    fi
    pr_base="${pr_range%...*}"
    log_info "PR range: ${CYAN}$pr_range${NC}"
    FILES_TO_CHECK=$(get_pr_files "$pr_range" "$FILE_PATTERNS" "$EXCLUDE_PATTERNS")
    if [[ -z "$FILES_TO_CHECK" ]]; then
      log_warning "No matching files changed in PR"
      echo ""
      exit 0
    fi
  elif [[ "$ci_mode" == true ]]; then
    FILES_TO_CHECK=$(get_ci_files "$FILE_PATTERNS" "$EXCLUDE_PATTERNS")
    if [[ -z "$FILES_TO_CHECK" ]]; then
      log_warning "No matching files changed in last commit"
      echo ""
      exit 0
    fi
  else
    FILES_TO_CHECK=$(get_staged_files "$FILE_PATTERNS" "$EXCLUDE_PATTERNS")
    if [[ -z "$FILES_TO_CHECK" ]]; then
      log_warning "No matching files staged for commit"
      echo ""
      exit 0
    fi
  fi

  # Exclude binary files
  local binary_files
  binary_files=$(get_binary_staged_files)
  if [[ -n "$binary_files" ]]; then
    FILES_TO_CHECK=$(filter_binary_files "$FILES_TO_CHECK" "$binary_files")

    # Count and list excluded binaries
    local binary_count=0
    local binary_list=""
    while IFS= read -r file; do
      if [[ -n "$file" ]]; then
        binary_count=$((binary_count + 1))
        if [[ -n "$binary_list" ]]; then
          binary_list="$binary_list, $file"
        else
          binary_list="$file"
        fi
      fi
    done <<< "$binary_files"

    if [[ $binary_count -gt 0 ]]; then
      log_info "Excluded $binary_count binary file(s): $binary_list"
    fi

    # Check if any files remain after excluding binaries
    if [[ -z "$FILES_TO_CHECK" ]]; then
      log_warning "No text files to review (only binary files staged)"
      echo ""
      exit 0
    fi
  fi

  # Check file sizes
  if [[ "$force_mode" != "true" && -n "$MAX_FILE_SIZE" && "$MAX_FILE_SIZE" != "0" ]]; then
    local large_files
    large_files=$(check_file_sizes "$FILES_TO_CHECK" "$MAX_FILE_SIZE" "$use_staged")

    if [[ -n "$large_files" ]]; then
      local max_size_human
      max_size_human=$(format_file_size "$MAX_FILE_SIZE")

      echo ""
      log_warning "Files exceed MAX_FILE_SIZE ($max_size_human):"
      while IFS=':' read -r file size; do
        if [[ -n "$file" ]]; then
          local size_human
          size_human=$(format_file_size "$size")
          echo "  - $file ($size_human)"
        fi
      done <<< "$large_files"
      echo ""
      echo "Options:"
      echo "  1. Exclude these files from staging: git reset HEAD <file>"
      echo "  2. Increase MAX_FILE_SIZE in .gga"
      echo "  3. Use --force to review anyway (may fail due to context limits)"
      echo ""
      exit 1
    fi
  fi

  # Initialize/validate cache
  local files_to_review="$FILES_TO_CHECK"
  local cache_initialized=false
  
  if [[ "$use_cache" == true ]]; then
    # Check if cache is valid, if not invalidate it
    if ! is_cache_valid "$RULES_FILE" ".gga"; then
      log_info "Cache invalidated (rules or config changed)"
      invalidate_cache
    fi
    
    # Initialize cache
    init_cache "$RULES_FILE" ".gga" > /dev/null
    cache_initialized=true
    
    # Filter out cached files
    files_to_review=$(filter_uncached_files "$FILES_TO_CHECK" "$use_staged")
    
    # Calculate cached files
    local total_count=0
    local uncached_count=0
    
    while IFS= read -r file; do
      [[ -n "$file" ]] && total_count=$((total_count + 1))
    done <<< "$FILES_TO_CHECK"
    
    while IFS= read -r file; do
      [[ -n "$file" ]] && uncached_count=$((uncached_count + 1))
    done <<< "$files_to_review"
    
    local cached_count=$((total_count - uncached_count))
    
    if [[ $cached_count -gt 0 ]]; then
      log_success "$cached_count file(s) passed from cache"
    fi
  fi

  echo -e "${BOLD}Files to review:${NC}"
  if [[ -z "$files_to_review" ]]; then
    echo -e "  ${GREEN}All files passed from cache!${NC}"
    echo ""
    log_success "CODE REVIEW PASSED (cached)"
    echo ""
    exit 0
  fi
  
  echo "$files_to_review" | while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      echo "  - $file"
    fi
  done
  echo ""

  # Read rules
  RULES=$(cat "$RULES_FILE")

  # Read commit message if provided (from commit-msg hook)
  local commit_msg=""
  if [[ -n "$commit_msg_file" && -f "$commit_msg_file" ]]; then
    commit_msg=$(cat "$commit_msg_file")
    log_info "Including commit message in review"
  fi

  # PR mode: single prompt without batching
  if [[ "$pr_mode" == "true" ]]; then
    # PR mode: use dedicated PR prompt builder
    local pr_diff=""
    if [[ "$diff_only" == "true" ]]; then
      pr_diff=$(get_pr_diff "$pr_range")
    fi
    local PROMPT
    PROMPT=$(build_pr_prompt "$RULES" "$files_to_review" "$diff_only" "$pr_diff" "$pr_base")

    # Execute review with timeout
    log_info "Sending to $PROVIDER for review (timeout: ${TIMEOUT}s)..."
    echo ""

    set +e
    start_spinner "Reviewing PR changes..."
    RESULT=$(execute_provider_with_timeout "$PROVIDER" "$PROMPT" "$TIMEOUT")
    EXEC_STATUS=$?
    stop_spinner
    set -e

    if [[ $EXEC_STATUS -eq 124 ]]; then
      log_error "Provider timed out after ${TIMEOUT}s"
      echo ""
      echo "The AI provider did not respond in time. This can happen with:"
      echo "  - Very large changesets (many files)"
      echo "  - Slow network or API rate limiting"
      echo ""
      echo "Try: Increase TIMEOUT in .gga config, or review fewer files."
      echo ""
      if [[ "$STRICT_MODE" == "true" ]]; then
        exit 1
      fi
      exit 0
    fi

    if [[ $EXEC_STATUS -ne 0 ]]; then
      log_error "Provider execution failed (exit code: $EXEC_STATUS)"
      if [[ -n "$RESULT" ]]; then
        echo ""
        echo "$RESULT"
        echo ""
      fi
      if [[ "$STRICT_MODE" == "true" ]]; then
        exit 1
      fi
      exit 0
    fi

    # Process PR mode result (single result, no batching)
    format_review_output "$RESULT"

    local status_check
    status_check=$(echo "$RESULT" | head -n 15)

    if echo "$status_check" | grep -q "STATUS: PASSED"; then
      log_success "CODE REVIEW PASSED"
      echo ""
      exit 0
    elif echo "$status_check" | grep -q "STATUS: FAILED"; then
      log_error "CODE REVIEW FAILED"
      echo ""
      echo "Fix the violations listed above before merging."
      echo ""
      exit 1
    else
      if [[ "$STRICT_MODE" == "true" ]]; then
        log_warning "Ambiguous response from AI"
        exit 1
      fi
      exit 0
    fi
  fi

  # Normal/CI mode: use batching with retry support
  # Check if batching is needed
  local batch_output
  batch_output=$(split_files_into_batches "$files_to_review" "$MAX_PROMPT_SIZE" "$use_staged" "$RULES")
  local num_batches
  num_batches=$(count_batches "$batch_output")

  if [[ $num_batches -gt 1 ]]; then
    log_info "Large commit: splitting into $num_batches batches"
  fi

  # Execute review with retry support
  log_info "Sending to $PROVIDER for review (timeout: ${TIMEOUT}s)..."
  if [[ -n "$FALLBACK_PROVIDER" ]]; then
    log_info "Fallback: $FALLBACK_PROVIDER"
  fi
  echo ""

  # Process batches
  local all_results=""
  local any_failed=false
  local any_error=false
  local all_findings=""
  local batch_num=1
  local passed_files=""

  while [[ $batch_num -le $num_batches ]]; do
    local batch_files
    batch_files=$(get_batch "$batch_output" "$batch_num")

    if [[ -z "$batch_files" ]]; then
      batch_num=$((batch_num + 1))
      continue
    fi

    if [[ $num_batches -gt 1 ]]; then
      echo -e "${CYAN}Processing batch $batch_num/$num_batches...${NC}"
    fi

    # Build prompt for this batch
    local PROMPT
    PROMPT=$(build_prompt "$RULES" "$batch_files" "$use_staged" "$commit_msg")

    start_spinner "Reviewing code..."
    local RESULT
    RESULT=$(execute_with_retry "$PROVIDER" "$PROMPT" "$RETRY_COUNT" "$RETRY_DELAY" "$FALLBACK_PROVIDER")
    local EXEC_STATUS=$?
    stop_spinner

    if [[ $EXEC_STATUS -ne 0 ]]; then
      log_error "Provider execution failed for batch $batch_num"
      any_error=true
      batch_num=$((batch_num + 1))
      continue
    fi

    # Parse result for this batch
    local status_check
    status_check=$(echo "$RESULT" | head -n 15)

    if echo "$status_check" | grep -q "STATUS: PASSED"; then
      # Track passed files for caching
      if [[ -n "$passed_files" ]]; then
        passed_files="$passed_files"$'\n'"$batch_files"
      else
        passed_files="$batch_files"
      fi
      if [[ $num_batches -gt 1 ]]; then
        log_success "Batch $batch_num: PASSED"
        echo ""
      fi
    elif echo "$status_check" | grep -q "STATUS: FAILED"; then
      any_failed=true
      # Extract findings from this batch
      local batch_findings
      batch_findings=$(echo "$RESULT" | grep -E "^#[0-9]+" || true)
      if [[ -n "$batch_findings" ]]; then
        if [[ -n "$all_findings" ]]; then
          all_findings="$all_findings"$'\n'"$batch_findings"
        else
          all_findings="$batch_findings"
        fi
      fi
      if [[ $num_batches -gt 1 ]]; then
        log_error "Batch $batch_num: FAILED"
        echo ""
      fi
      # Store full result for later
      if [[ -n "$all_results" ]]; then
        all_results="$all_results"$'\n\n'"$RESULT"
      else
        all_results="$RESULT"
      fi
    else
      # Ambiguous result
      if [[ "$STRICT_MODE" == "true" ]]; then
        any_error=true
        if [[ $num_batches -gt 1 ]]; then
          log_warning "Batch $batch_num: Ambiguous response"
        fi
      fi
    fi

    batch_num=$((batch_num + 1))
  done

  echo ""

  # Handle overall result
  if [[ "$any_error" == true && "$STRICT_MODE" == "true" ]]; then
    log_error "Provider execution failed"
    exit 1
  fi

  if [[ "$any_failed" == true ]]; then
    # Show combined findings
    if [[ $num_batches -gt 1 && -n "$all_findings" ]]; then
      echo -e "${CYAN}─────────${NC} ${BOLD}Combined Review Results${NC} ${CYAN}─────────${NC}"
      echo ""
      echo -e "${RED}${BOLD}STATUS: FAILED${NC}"
      echo ""
      # Renumber findings for combined output with colors
      local finding_num=1
      while IFS= read -r finding; do
        if [[ -n "$finding" ]]; then
          # Replace #N with new sequential number and apply colors
          local finding_rest
          finding_rest=$(echo "$finding" | sed 's/^#[0-9]* //')
          # Extract file reference and rest for coloring
          if [[ "$finding_rest" =~ ^([^[:space:]]+)(.*) ]]; then
            local file_ref="${BASH_REMATCH[1]}"
            local desc="${BASH_REMATCH[2]}"
            echo -e "${YELLOW}#${finding_num}${NC} ${CYAN}${file_ref}${NC}${desc}"
          else
            echo -e "${YELLOW}#${finding_num}${NC} ${finding_rest}"
          fi
          finding_num=$((finding_num + 1))
        fi
      done <<< "$all_findings"
      echo ""
      echo -e "${CYAN}──────────────────────────────────${NC}"
    else
      # Single batch, show original output
      format_review_output "$all_results"
    fi

    log_error "CODE REVIEW FAILED"

    # Interactive dismiss flow (only in terminal, not CI)
    if [[ -t 1 && "$ci_mode" != true ]]; then
      local dismiss_result=0
      prompt_dismiss_findings "$all_results" || dismiss_result=$?

      if [[ $dismiss_result -eq 0 ]]; then
        # All findings dismissed
        log_success "CODE REVIEW PASSED"
        echo ""
        exit 0
      fi
    fi

    echo ""
    echo "Fix the violations listed above before committing."
    echo ""
    exit 1
  fi

  # All batches passed
  # Cache the passed files
  if [[ "$cache_initialized" == true && -n "$passed_files" ]]; then
    cache_files_passed "$passed_files" "$use_staged"
  fi
  log_success "CODE REVIEW PASSED"
  echo ""
  exit 0
}

# ============================================================================
# Utility Functions
# ============================================================================

get_staged_files() {
  local patterns="$1"
  local excludes="$2"

  # Get all staged files (added, copied, modified)
  local staged
  staged=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null)

  if [[ -z "$staged" ]]; then
    return
  fi

  # Convert comma-separated patterns to array
  IFS=',' read -ra PATTERN_ARRAY <<< "$patterns"
  IFS=',' read -ra EXCLUDE_ARRAY <<< "$excludes"

  # Filter files
  echo "$staged" | while IFS= read -r file; do
    local match=false
    local excluded=false

    # Check if file matches any include pattern
    for pattern in "${PATTERN_ARRAY[@]}"; do
      pattern=$(echo "$pattern" | xargs) # trim whitespace
      # Convert glob pattern to regex-like suffix match
      # *.tsx -> check if file ends with .tsx
      if [[ "$pattern" == \** ]]; then
        # Pattern starts with *, so match suffix
        local suffix="${pattern#\*}"
        if [[ "$file" == *"$suffix" ]]; then
          match=true
          break
        fi
      else
        # Exact match or other pattern
        # shellcheck disable=SC2053
        if [[ "$file" == $pattern ]] || [[ "$(basename "$file")" == $pattern ]]; then
          match=true
          break
        fi
      fi
    done

    # Check if file matches any exclude pattern
    if [[ "$match" == true && -n "$excludes" ]]; then
      for pattern in "${EXCLUDE_ARRAY[@]}"; do
        pattern=$(echo "$pattern" | xargs) # trim whitespace
        # Convert glob pattern to regex-like suffix match
        if [[ "$pattern" == \** ]]; then
          local suffix="${pattern#\*}"
          if [[ "$file" == *"$suffix" ]]; then
            excluded=true
            break
          fi
        else
          # shellcheck disable=SC2053
          if [[ "$file" == $pattern ]] || [[ "$(basename "$file")" == $pattern ]]; then
            excluded=true
            break
          fi
        fi
      done
    fi

    if [[ "$match" == true && "$excluded" == false ]]; then
      echo "$file"
    fi
  done
}

get_binary_staged_files() {
  # Returns list of binary files in the staging area
  # Binary files show as "-<TAB>-<TAB>filename" in git diff --numstat
  # Uses process substitution to avoid subshell issues with pipe
  while IFS=$'\t' read -r added deleted file; do
    if [[ "$added" == "-" && "$deleted" == "-" ]]; then
      echo "$file"
    fi
  done < <(git diff --cached --numstat --diff-filter=ACM 2>/dev/null)
}

filter_binary_files() {
  # Removes binary files from a list of files
  # $1: newline-separated list of files
  # $2: newline-separated list of binary files to exclude
  local files="$1"
  local binaries="$2"

  if [[ -z "$binaries" ]]; then
    echo "$files"
    return
  fi

  echo "$files" | while IFS= read -r file; do
    if [[ -n "$file" ]] && ! echo "$binaries" | grep -qxF "$file"; then
      echo "$file"
    fi
  done
}

check_file_sizes() {
  # Checks if any files exceed MAX_FILE_SIZE
  # $1: newline-separated list of files
  # $2: max file size in bytes (0 = no limit)
  # $3: use_staged - if "true", check staged content size
  # Returns: newline-separated list of files exceeding limit (empty if none)
  local files="$1"
  local max_size="$2"
  local use_staged="${3:-false}"

  # No limit if max_size is 0 or empty
  if [[ -z "$max_size" || "$max_size" == "0" ]]; then
    return
  fi

  while IFS= read -r file; do
    if [[ -z "$file" ]]; then
      continue
    fi

    local file_size
    if [[ "$use_staged" == "true" ]]; then
      # Get size of staged content
      file_size=$(git show ":$file" 2>/dev/null | wc -c)
    else
      # Get size from filesystem
      if [[ -f "$file" ]]; then
        file_size=$(wc -c < "$file")
      else
        file_size=0
      fi
    fi

    if [[ "$file_size" -gt "$max_size" ]]; then
      echo "$file:$file_size"
    fi
  done <<< "$files"
}

format_file_size() {
  # Formats bytes into human-readable format
  local bytes="$1"
  if [[ "$bytes" -ge 1048576 ]]; then
    echo "$(awk "BEGIN {printf \"%.1f\", $bytes/1048576}")MB"
  elif [[ "$bytes" -ge 1024 ]]; then
    echo "$(awk "BEGIN {printf \"%.1f\", $bytes/1024}")KB"
  else
    echo "${bytes}B"
  fi
}

# ============================================================================
# Batching Functions
# ============================================================================

calculate_file_content_size() {
  # Calculates the content size of a single file
  # $1: file path
  # $2: use_staged - if "true", get staged content size
  # Returns: size in characters (bytes)
  local file="$1"
  local use_staged="${2:-false}"

  if [[ -z "$file" ]]; then
    echo "0"
    return
  fi

  local size
  if [[ "$use_staged" == "true" ]]; then
    size=$(git show ":$file" 2>/dev/null | wc -c)
  else
    if [[ -f "$file" ]]; then
      size=$(wc -c < "$file")
    else
      size=0
    fi
  fi

  echo "$size"
}

calculate_prompt_overhead() {
  # Calculates the approximate overhead of the prompt template (without file contents)
  # This includes: instructions, rules file, headers, etc.
  # $1: rules content
  # Returns: overhead size in characters
  local rules="$1"
  local rules_size=${#rules}

  # Approximate overhead from prompt template:
  # - Instructions: ~500 chars
  # - Headers and separators: ~200 chars
  # - Per-file overhead (filename markers): counted separately
  local base_overhead=700
  echo $((base_overhead + rules_size))
}

calculate_prompt_size_for_files() {
  # Calculates the total prompt size for a list of files
  # $1: newline-separated list of files
  # $2: use_staged
  # $3: rules content
  # Returns: total size in characters
  local files="$1"
  local use_staged="${2:-false}"
  local rules="${3:-}"

  local total_size=0

  # Add overhead
  total_size=$(calculate_prompt_overhead "$rules")

  # Add file contents and per-file overhead (~30 chars for "--- FILE: xxx ---\n")
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      local file_size
      file_size=$(calculate_file_content_size "$file" "$use_staged")
      # Add file content size + overhead for file header
      total_size=$((total_size + file_size + 30 + ${#file}))
    fi
  done <<< "$files"

  echo "$total_size"
}

split_files_into_batches() {
  # Splits a list of files into batches that fit within max_prompt_size
  # $1: newline-separated list of files
  # $2: max_prompt_size (0 = no splitting)
  # $3: use_staged
  # $4: rules content
  # Returns: batches separated by "---BATCH---" marker
  local files="$1"
  local max_size="${2:-0}"
  local use_staged="${3:-false}"
  local rules="${4:-}"

  # No splitting if max_size is 0 or empty
  if [[ -z "$max_size" || "$max_size" == "0" ]]; then
    echo "$files"
    return
  fi

  local overhead
  overhead=$(calculate_prompt_overhead "$rules")

  # Available space for file contents
  local available_space=$((max_size - overhead))

  if [[ $available_space -le 0 ]]; then
    # Rules file alone exceeds limit, can't batch effectively
    echo "$files"
    return
  fi

  local current_batch=""
  local current_batch_size=0
  local batch_count=0

  while IFS= read -r file; do
    if [[ -z "$file" ]]; then
      continue
    fi

    local file_size
    file_size=$(calculate_file_content_size "$file" "$use_staged")
    local file_overhead=$((30 + ${#file}))
    local total_file_size=$((file_size + file_overhead))

    # Check if adding this file would exceed the limit
    if [[ $current_batch_size -gt 0 && $((current_batch_size + total_file_size)) -gt $available_space ]]; then
      # Output current batch and start new one
      if [[ $batch_count -gt 0 ]]; then
        echo ""
        echo "---BATCH---"
      fi
      printf '%s' "$current_batch"
      batch_count=$((batch_count + 1))
      current_batch=""
      current_batch_size=0
    fi

    # Add file to current batch
    if [[ -n "$current_batch" ]]; then
      current_batch="$current_batch"$'\n'"$file"
    else
      current_batch="$file"
    fi
    current_batch_size=$((current_batch_size + total_file_size))
  done <<< "$files"

  # Output final batch
  if [[ -n "$current_batch" ]]; then
    if [[ $batch_count -gt 0 ]]; then
      echo ""
      echo "---BATCH---"
    fi
    printf '%s\n' "$current_batch"
  fi
}

count_batches() {
  # Counts the number of batches in batch output
  # $1: batch output from split_files_into_batches
  # Returns: number of batches
  local batch_output="$1"

  if [[ -z "$batch_output" ]]; then
    echo "0"
    return
  fi

  local count
  count=$(echo "$batch_output" | grep -c "^---BATCH---$" || true)
  echo $((count + 1))
}

get_batch() {
  # Gets a specific batch from batch output
  # $1: batch output from split_files_into_batches
  # $2: batch number (1-indexed)
  # Returns: files in that batch (newline-separated)
  local batch_output="$1"
  local batch_num="$2"

  if [[ -z "$batch_output" || -z "$batch_num" ]]; then
    return
  fi

  # Split by ---BATCH--- and get the nth segment
  local current_batch=0
  local in_target_batch=false
  local result=""

  while IFS= read -r line; do
    if [[ "$line" == "---BATCH---" ]]; then
      current_batch=$((current_batch + 1))
      if [[ "$in_target_batch" == true ]]; then
        break
      fi
      if [[ $current_batch -eq $((batch_num - 1)) ]]; then
        in_target_batch=true
      fi
      continue
    fi

    if [[ $current_batch -eq 0 && $batch_num -eq 1 ]]; then
      # First batch (before any marker)
      if [[ -n "$line" ]]; then
        if [[ -n "$result" ]]; then
          result="$result"$'\n'"$line"
        else
          result="$line"
        fi
      fi
    elif [[ "$in_target_batch" == true ]]; then
      if [[ -n "$line" ]]; then
        if [[ -n "$result" ]]; then
          result="$result"$'\n'"$line"
        else
          result="$line"
        fi
      fi
    fi
  done <<< "$batch_output"

  echo "$result"
}

get_ci_files() {
  local patterns="$1"
  local excludes="$2"
  local source_commit="HEAD~1"

  if [[ -n ${GGA_CI_SOURCE_COMMIT:-} ]]; then
    source_commit="${GGA_CI_SOURCE_COMMIT}"
  fi

  # Get files changed in the last commit (for CI environments)
  local changed
  changed=$(git diff --name-only --diff-filter=ACM "$source_commit"..HEAD 2>/dev/null)
  if [[ -z "$changed" ]]; then
    return
  fi

  # Convert comma-separated patterns to array
  IFS=',' read -ra PATTERN_ARRAY <<< "$patterns"
  IFS=',' read -ra EXCLUDE_ARRAY <<< "$excludes"

  # Filter files (same logic as get_staged_files)
  echo "$changed" | while IFS= read -r file; do
    local match=false
    local excluded=false

    # Check if file matches any include pattern
    for pattern in "${PATTERN_ARRAY[@]}"; do
      pattern=$(echo "$pattern" | xargs) # trim whitespace
      if [[ "$pattern" == \** ]]; then
        local suffix="${pattern#\*}"
        if [[ "$file" == *"$suffix" ]]; then
          match=true
          break
        fi
      else
        # shellcheck disable=SC2053
        if [[ "$file" == $pattern ]] || [[ "$(basename "$file")" == $pattern ]]; then
          match=true
          break
        fi
      fi
    done

    # Check if file matches any exclude pattern
    if [[ "$match" == true && -n "$excludes" ]]; then
      for pattern in "${EXCLUDE_ARRAY[@]}"; do
        pattern=$(echo "$pattern" | xargs) # trim whitespace
        if [[ "$pattern" == \** ]]; then
          local suffix="${pattern#\*}"
          if [[ "$file" == *"$suffix" ]]; then
            excluded=true
            break
          fi
        else
          # shellcheck disable=SC2053
          if [[ "$file" == $pattern ]] || [[ "$(basename "$file")" == $pattern ]]; then
            excluded=true
            break
          fi
        fi
      done
    fi

    if [[ "$match" == true && "$excluded" == false ]]; then
      # Only include if file still exists (wasn't deleted)
      if [[ -f "$file" ]]; then
        echo "$file"
      fi
    fi
  done
}

build_prompt() {
  local rules="$1"
  local files="$2"
  local use_staged="${3:-true}"  # Read from staging area by default
  local commit_msg="${4:-}"      # Optional commit message

  # Load .gga-ignore entries and inject as exceptions
  local ignore_entries
  ignore_entries=$(load_gga_ignore)

  # Start building the prompt
  cat << EOF
You are a code reviewer. Analyze the files below and validate they comply with the coding standards provided.

=== CODING STANDARDS ===
$rules
=== END CODING STANDARDS ===
EOF

  # Inject exceptions from .gga-ignore
  if [[ -n "$ignore_entries" ]]; then
    echo ""
    echo "=== EXCEPTIONS (do not flag these) ==="
    while IFS= read -r entry; do
      local entry_file_line entry_reason
      entry_file_line=$(echo "$entry" | sed 's/[[:space:]]*#.*$//' | sed 's/[[:space:]]*$//')
      entry_reason=$(echo "$entry" | grep -o '#.*$' | sed 's/^#[[:space:]]*//' || true)
      if [[ -n "$entry_reason" ]]; then
        echo "- ${entry_file_line} (reason: ${entry_reason})"
      else
        echo "- ${entry_file_line}"
      fi
    done <<< "$ignore_entries"
    echo "=== END EXCEPTIONS ==="
  fi

  # Include commit message if provided (from commit-msg hook)
  if [[ -n "$commit_msg" ]]; then
    cat << EOF

=== COMMIT MESSAGE ===
$commit_msg
=== END COMMIT MESSAGE ===
EOF
  fi

  cat << 'EOF'

=== FILES TO REVIEW ===
EOF

  # Add file contents
  # In normal mode (pre-commit): read from staging area with "git show :file"
  # In CI mode: read from working directory (files are already committed)
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      echo ""
      echo "--- FILE: $file ---"
      if [[ "$use_staged" == "true" ]]; then
        # Read from staging area (index) - this ensures we review exactly what will be committed
        git show ":$file" 2>/dev/null || {
          log_warning "Could not read staged content for: $file"
        }
      else
        # CI mode: read from filesystem (file is already committed)
        if [[ -f "$file" ]]; then
          cat "$file"
        fi
      fi
    fi
  done <<< "$files"

  cat << 'EOF'

=== END FILES ===

**IMPORTANT: Your response MUST include one of these lines near the beginning:**
STATUS: PASSED
STATUS: FAILED

**If FAILED:** List each violation numbered with #N prefix:
#1 file:line - rule violated - description
#2 file:line - rule violated - description
...

**If PASSED:** Confirm all files comply with the coding standards.

**Begin with STATUS:**
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
  case "${1:-}" in
    run)
      shift
      cmd_run "$@"
      ;;
    install)
      shift
      cmd_install "$@"
      ;;
    uninstall)
      cmd_uninstall
      ;;
    config)
      cmd_config
      ;;
    init)
      cmd_init
      ;;
    cache)
      shift
      cmd_cache "$@"
      ;;
    ignore)
      shift
      cmd_ignore "$@"
      ;;
    version|--version|-v)
      print_version
      ;;
    help|--help|-h|"")
      print_help
      ;;
    *)
      log_error "Unknown command: $1"
      echo ""
      print_help
      exit 1
      ;;
  esac
}

main "$@"
